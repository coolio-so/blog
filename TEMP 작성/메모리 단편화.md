# 메모리 단편화
가상기억장치를 관리하기 위해서 고정길이 크기로 분할하여 관리하는 것은 페이지(Page)이고, 가변길이로 관리하는 것은 세그먼트(Segment)이다.

구분 | Paging 기법 | Segmentation 기법
:---------:|----------|---------
 할당 | 고정(Static) 분할 | 가변(Dynamic) 분할
 적재 | 요구 Page만 일부 적재(On-Demand) | 프로그램 전체 적재
 관점 | 메모리 관리 측면 | 파일 관리 측면
 장점 | - 요구 Page만 온디멘드 Load<br>- 외부 단편화 해결<br>- 교체시간 최소 | - 사용자 관점에서 프로그램 용이<br>- 내부 단편화 해결<br>- 코드, 데이터 공유 용이
 단점 | - 내부 단편화(Fragmentation) 발생<br>- Trashing, 잦은 디스크 I/O 유발 | - 외부 단편화 심각<br>- 메인 메모리가 커야 함

## 내부 단편화(Internal Fragmentation)
메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황.
- 예를 들어 메모장을 켰는데 OS가 4kb를 할당해줬다. 그런데 사실상 1kb 만큼만 사용하고 있을 때 필요 이상으로 프로세스가 메모리를 할당받았으므로 내부 단편화가 3kb 만큼 생긴 것

## 외부 단편화(External Fragmentation)
메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다. 이 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황
- 예를 들어 메모리 처음 주소에 8mb짜리 프로세스가 할당되었고 바로 이어서 16mb짜리 프로세스가 할당되었다고 가정했을 때 8mb짜리 프로세스를 종료시키면 메모리 처음 주소부터 8mb만큼 공간이 생긴다.
- 이런 식으로 계속해서 빈 메모리가 쌓이는데 예를 들어서 빈 메모리의 공간중에 제일 큰 빈 메모리가 8mb라고 한다면 9mb짜리 프로세스를 할당을 해야할 때 마땅한 공간은 없지만 전체적으로 메모리 여유는 있을 때 외부단편화가 생겼다고 한다.

# 메모리 파편화 문제 해결 방법

## Paging 기법(가상메모리 사용, 외부 단편화 해결, 내부 단편화 존재)
보조기억장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 하고 RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 할 때, 페이징 기법이란 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법.  
페이지와 프레임을 대응시키기 위해 Page Mapping 과정이 필요해서 Paging Table을 만든다.  
페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다. 대신 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다.  

_* 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 Paging Mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다._

## Segmentation 기법(가상메모리 사용, 내부 단편화 해결, 외부 단편화 존재)
페이징 기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환을 하게 된다.  
각 세그먼트는 연속적인 공간에 저장되어 있다.  
세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다. 마찬가지로 Mapping을 위해 세그먼트 테이블이 필요하다.(각 세그먼트 항목별 세그먼트 시작주소와 세그먼트의 길이 정보를 가지고 있음)  
프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화는 일어나지 않으나 여전히 중간에 프로세스가 메모리를 해제하면 생기는 구멍, 즉 외부 단편화 문제는 여전히 존재한다.

## 메모리 풀(Memory Pool)
필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법이다.  메모리 풀 없이 동적할당과 해제를 반복하면 메모리의 랜덤한(실제로는 알고리즘에 의한)위치에 할당과 해제가 반복되면서 단편화를 일으킬 수 있겠지만 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다. 또한 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.  
하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우에는 사용하지 않아야 한다. 메모리 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다. 미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식이다.